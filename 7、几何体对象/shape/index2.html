<!DOCTYPE html>
<html lang="en">
	<head>
		<title>geometry - shapes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
		</style>
	</head>
	<body>

		<div id="info">Simple procedurally-generated shapes</div>

		<script type="module">

            import * as THREE from '../../js/three.js';


			let container;

			let camera, scene, renderer;

			let group;

			let targetRotation = 0;
			let targetRotationOnPointerDown = 0;

			let pointerX = 0;
			let pointerXOnPointerDown = 0;

			let windowHalfX = window.innerWidth / 2;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 150, 500 );
				scene.add( camera );

				const light = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( light );

				group = new THREE.Group();
				group.position.y = 50;
				scene.add( group );

				const loader = new THREE.TextureLoader();
				const texture = loader.load( "../../textures/uv_grid_opengl.jpg" );

				// it's necessary to apply these settings in order to correctly display the texture on a shape geometry

				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 0.008, 0.008 );

				function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {

					// flat shape with texture
					// note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

					let geometry = new THREE.ShapeGeometry( shape );

					let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );
					mesh.position.set( x, y, z - 175 );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );
					// group.add( mesh );

					// flat shape

					geometry = new THREE.ShapeGeometry( shape );

					mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
					mesh.position.set( x, y, z - 125 );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );
					// group.add( mesh );

					// extruded shape

					geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

					mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );
					mesh.position.set( x, y, z - 75 );
					mesh.rotation.set( rx, ry, rz );
					mesh.scale.set( s, s, s );
					group.add( mesh );

					addLineShape( shape, color, x, y, z, rx, ry, rz, s );

				}

				function addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {

					// lines

					shape.autoClose = true;

					const points = shape.getPoints();
					const spacedPoints = shape.getSpacedPoints( 500 );

					const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
					const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );

					// solid line 实线

					let line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
					line.position.set( x, y, z - 25 );
					line.rotation.set( rx, ry, rz );
					line.scale.set( s, s, s );
					group.add( line )

				}

				// Arc circle

				const arcShape = new THREE.Shape()
					.moveTo( 50, 10 )
					.absarc( 10, 10, 40, 0, Math.PI * 2, false );

				const holePath = new THREE.Path()
					.moveTo( 20, 10 )
					.absarc( 10, 10, 10, 0, Math.PI * 2, true );

				arcShape.holes.push( holePath );


				


				const extrudeSettings = { depth: 18, bevelEnabled: true, bevelSegments: 64, steps: 64, bevelSize: 1, bevelThickness: 1 };

				// addShape( shape, color, x, y, z, rx, ry,rz, s );

				// addShape( californiaShape, extrudeSettings, 0xf08000, - 300, - 100, 0, 0, 0, 0, 1 );
				// addShape( triangleShape, extrudeSettings, 0x8080f0, - 180, 0, 0, 0, 0, 0, 1 );
				// addShape( roundedRectShape, extrudeSettings, 0x008000, - 150, 150, 0, 0, 0, 0, 1 );
				// addShape( trackShape, extrudeSettings, 0x008080, 200, - 100, 0, 0, 0, 0, 1 );
				// addShape( squareShape, extrudeSettings, 0x0040f0, 150, 100, 0, 0, 0, 0, 1 );
				// addShape( heartShape, extrudeSettings, 0xf00000, 60, 100, 0, 0, 0, Math.PI, 1 );
				//  addShape( circleShape, extrudeSettings, 0x00f000, 120, 250, 0, 0, 0, 0, 1 );
				// addShape( fishShape, extrudeSettings, 0x404040, - 60, 200, 0, 0, 0, 0, 1 );
				// addShape( smileyShape, extrudeSettings, 0xf000f0, - 200, 250, 0, 0, 0, Math.PI, 1 );
				addShape( arcShape, extrudeSettings, 0x804000, 150, 0, 0, 0, 0, 0, 1 );
				// addShape( splineShape, extrudeSettings, 0x808080, - 50, - 100, 0, 0, 0, 0, 1 );

				// addLineShape( arcShape.holes[ 0 ], 0x804000, 150, 0, 0, 0, 0, 0, 1 );

				// for ( let i = 0; i < smileyShape.holes.length; i += 1 ) {

				// 	addLineShape( smileyShape.holes[ i ], 0xf000f0, - 200, 250, 0, 0, 0, Math.PI, 1 );

				// }

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				// 

				container.style.touchAction = 'none';
				container.addEventListener( 'pointerdown', onPointerDown );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onPointerDown( event ) {

				if ( event.isPrimary === false ) return;

				pointerXOnPointerDown = event.clientX - windowHalfX;
				targetRotationOnPointerDown = targetRotation;

				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerup', onPointerUp );

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				pointerX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

			}

			function onPointerUp() {

				if ( event.isPrimary === false ) return;

				document.removeEventListener( 'pointermove', onPointerMove );
				document.removeEventListener( 'pointerup', onPointerUp );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
